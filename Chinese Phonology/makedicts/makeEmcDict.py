# -*- coding: utf-8 -*-
import codecs, pickle, utilities

lineToCodepoints = utilities.lineToCodepoints
pp = utilities.pp

# Pulleyblank's Early Middle Chinese autogenerated

# The strategy is to derive a phonetic representation from features
# whose value is deduced from the Yunjing tables and the Guangyun
# finals. These dictionaries hold default values which are modified
# in particular cases noted later.
# Based on Pulleyblank, Middle Chinese, Appendix I.

# Dictionaries
# Initials by Yunjing column
initialDict = { 1:u"p",  2:u"p‘",    3:u"b",   4:u"m",
                5:u"t",  6:u"t‘",    7:u"d",   8:u"n",
                9:u"k",  10:u"k‘",  11:u"g",  12:u"ŋ",
               13:u"ts", 14:u"ts‘", 15:u"dz", 16:u"s", 17:u"z",
               18:u"ʔ",  19:u"x",   20:u"ɣ",  21:u"j",
               22:u"l",23:u"ɲ"}
# Place of articulation by groupings of Yunjing colums
articulationDict = { 1:u"p",   2:u"p",   3:u"p",   4:u"p",
                     5:u"t",   6:u"t",   7:u"t",   8:u"t",
                     9:u"k",  10:u"k",  11:u"k",  12:u"k",
                    13:u"ts", 14:u"ts", 15:u"ts", 16:u"ts", 17:u"ts",
                    18:u"h",  19:u"h",   20:u"h",21:u"h",
                    22:u"l",  23:u"r"}
# In grades II and III, retroflexes and palatals correspond to dentals elsewhere.
retroflexStopInitialDict = {5:u"tr", 6:u"tr‘",7:u"dr",8:u"nr"}
retroflexSibilantInitialDict = {13:u"tʂ",14:u"tʂ‘",15:u"dʐ",16:u"ʂ",17:u"ʐ"}
palatalSibilantInitialDict = {13:u"tɕ",14:u"tɕ‘",15:u"ʑ",16:u"ɕ",17:u"dʑ"}

# Yunjing and Guangyun dictionaries needed
f=codecs.open("..\\dicts\\yunjingDict.py","rb")
yunjingDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\yunjingRhymeToKaiheDict.py","rb")
yunjingRhymeToKaiheDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\yunjingRhymeToNeiwaiDict.py","rb")
yunjingRhymeToNeiwaiDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\guangyunHomophoneDict.py","rb")
guangyunHomophoneDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\guangyunFinalDict.py","rb")
guangyunFinalDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\emcFinalDict.py","rb")
emcFinalDict = pickle.load(f)
f.close()

# Match each final in Guangyun to the corresponding entry in Yunjing
# and get the Yunjing initial, grade, rhyme and kaihe
emcFeatures = []
for gyId in guangyunHomophoneDict:
    final = guangyunHomophoneDict[gyId]["final"]
    guangyunRhyme = emcFinalDict[final]["rhyme"]
    tone = guangyunFinalDict[final]["tone"]
    yjId = guangyunHomophoneDict[gyId]["yunjing"]
    initial = yunjingDict[yjId]["initial"]
    grade = yunjingDict[yjId]["grade"]
    yunjingRhyme = yunjingDict[yjId]["rhyme"]
    kaihe = yunjingRhymeToKaiheDict[yunjingRhyme]["corrected"]
    emcFeatures.append([gyId,initial,final,guangyunRhyme,grade,yunjingRhyme,kaihe,tone])                                  

# Generate Early Middle Chinese from the features
emcDict = {}
emcFeaturesDict = {}        # holds information needed to generate Baxter and Karlgren.
for line in emcFeatures:    # We persist it as a dictionary because it is also needed
    gyId = line[0]          # to generate Old Chinese.
    number = int(guangyunHomophoneDict[gyId]["number"]) # temp
    initial = line[1]
    final = line[2]
    guangyunRhyme = line[3]
    grade = line[4]
    yunjingRhyme = line[5]
    kaihe = line[6]
    tone = line[7]
    #
    # Initials
    #
    emcInitial = initialDict[initial]
    # Grades 2 and 3 have retroflex stops.
    if grade in [2,3] and articulationDict[initial] == u't':
        emcInitial = retroflexStopInitialDict[initial]
    # Grade 2 has retroflex sibilants.
    elif grade == 2 and articulationDict[initial] == u'ts':
        emcInitial = retroflexSibilantInitialDict[initial]
    # Grade 3 has palatal sibilants.
    elif grade == 3 and articulationDict[initial] == u'ts':
        emcInitial = palatalSibilantInitialDict[initial]
    # Initial 21 corresponds to a glide: j in kaikou, w in hekou.
    if initial == 21 and kaihe == u"he":
        emcInitial = u"w"
    #
    # Finals
    #
    emcFinal = emcFinalDict[final][grade][kaihe]
    # Some entries in emcfinals.txt are marked with an asterisk:
    # these are conjectured values not directly warranted by Pulleyblank. 
    if emcFinal[0] == u"*":
        conjectural = True
        emcFinal = emcFinal[1:]
    else:
        conjectural = False
    # Grade 4 finals only have the glide j after labial, velar and laryngeal initials.
    if emcFinal[0] == u"j" and articulationDict[initial] not in [u"p", u"k", u"h"]:
        emcFinal = emcFinal[1:]
    # Where a glide is initial in the syllable, it is not part of the final.
    if emcInitial == u"j" and emcFinal[0] == u"j":
        emcFinal = emcFinal[1:]
    elif emcInitial == u"w" and emcFinal[0] == u"w":
        emcFinal = emcFinal[1:]
    elif emcInitial == "w" and emcFinal[0:2] == u"jw":
        emcFinal = emcFinal[0] + emcFinal[2:]
    #
    # Tone marks
    #
    # The tone marks used in the table are not superscripted:
    # replace them with superscripts.
    emcFinal = emcFinal.replace(u"ʔ",u"\u02c0")
    emcFinal = emcFinal.replace(u"h",u"\u02b0")
    #
    # Combine initial with final
    #
    emcReading = emcInitial + emcFinal
    if conjectural:
        emcReading = u"*" + emcReading
    emcDict[gyId] = emcReading
    emcFeaturesDict[gyId] = {}
    emcFeaturesDict[gyId]["emcinitial"]  = emcInitial
    emcFeaturesDict[gyId]["emcfinal"]  = emcFinal
    emcFeaturesDict[gyId]["guangyunrhyme"] = guangyunRhyme
    emcFeaturesDict[gyId]["final"]  = final
    emcFeaturesDict[gyId]["grade"]  = grade
    emcFeaturesDict[gyId]["kaihe"]  = kaihe
     
# Generate Baxter's Middle Chinese and Karlgren's  Ancient Chinese
# by simple translation from Pulleyblank's Early Middle Chinese
# with a couple of modifications.
# Based on Pulleyblank, Middle Chinese, Appendix I and Baxter,
# Old Chinese, chapter 10.

f=codecs.open("..\\dicts\\emcToMcbInitialDict.py","rb")
emcToMcbInitialDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\emcToMcbFinalDict.py","rb")
emcToMcbFinalDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\emcToMckInitialDict.py","rb")
emcToMckInitialDict = pickle.load(f)
f.close()

f=codecs.open("..\\dicts\\emcToMckFinalDict.py","rb")
emcToMckFinalDict = pickle.load(f)
f.close()

# Baxter
mcbDict = {}
mcbFeaturesDict = {} # Holds the same data as emcFeaturesDict but in Baxter's system
mcbId = 0
for emcId in emcFeaturesDict:
    emcInitial = emcFeaturesDict[emcId]["emcinitial"]
    emcFinal = emcFeaturesDict[emcId]["emcfinal"]
    final = emcFeaturesDict[emcId]["final"]
    grade = emcFeaturesDict[emcId]["grade"]
    kaihe = emcFeaturesDict[emcId]["kaihe"]
    if emcFinal[0] == u"*":
        conjectural = True
        emcFinal = emcFinal[1:]
    mcbInitial = emcToMcbInitialDict[emcInitial]
    mcbFinal = emcToMcbFinalDict[emcFinal]
    if final == 127 and kaihe == u"kai" and grade == 2:
        mcbFinal = u"æjH"
    elif final == 127 and kaihe == u"he" and grade == 2:
        mebFinal = u"wæjH"
    if len(mcbInitial) > 0 and mcbInitial[-1] == u"j" and mcbFinal[0] == u"j":
        mcbFinal = mcbFinal[1:]
    if len(mcbInitial) > 0 and mcbInitial[-1] == u"y" and mcbFinal[0] == u"j":
        mcbFinal = mcbFinal[1:]
    if len(mcbInitial) > 0 and mcbInitial[-1] == u"w" and mcbFinal[0] == u"w":
        mebFinal = mcbFinal[1:]
    mcbReading = mcbInitial + mcbFinal
    if conjectural:
        mcbReading = u"*" + mcbReading
    mcbDict[emcId] = mcbReading
    mcbFeaturesDict[emcId] = {}
    mcbFeaturesDict[gyId] = {}
    mcbFeaturesDict[gyId]["mcbinitial"]  = mcbInitial
    mcbFeaturesDict[gyId]["mcbfinal"]  = mcbFinal
    mcbFeaturesDict[gyId]["final"]  = final
    mcbFeaturesDict[gyId]["grade"]  = grade
    mcbFeaturesDict[gyId]["kaihe"]  = kaihe

# Karlgren
mckDict = {}
for emcId in emcFeaturesDict:
    emcInitial = emcFeaturesDict[emcId]["emcinitial"]
    emcFinal = emcFeaturesDict[emcId]["emcfinal"]
    if emcFinal[0] == u"*":
        conjectural = True
        emcFinal = emcFinal[1:]
    mckInitial = emcToMckInitialDict[emcInitial]
    mckFinal = emcToMckFinalDict[emcFinal]
    mckReading = mckInitial + mckFinal
    mckReading = mckReading
    mckReading = mckReading.replace(u"i̯ui̯u̯",u"i̯u")
    mckReading = mckReading.replace(u"i̯ui̯w̯",u"i̯w")
    mckReading = mckReading.replace(u"i̯u̯w̯",u"i̯w")
    mckReading = mckReading.replace(u"i̯ui̯",u"i̯u")
    mckReading = mckReading.replace(u"i̯i̯",u"i̯")
    mckReading = mckReading.replace(u"i̯uu",u"i̯u̯")
    if conjectural:
        mckReading = u"*" + mckReading
    mckDict[emcId] = mckReading

# DEBUG
yod = []
for emcId in mckDict.keys():
    mckReading = mckDict[emcId]
    emcReading = emcDict[emcId]
    mcbReading = mcbDict[emcId]
    if u"i̯" in mckReading[0:4]:
        if [mckReading,emcReading,mcbReading] not in yod:
            yod.append([mckReading,emcReading,mcbReading])
yod.sort()

# Write to file.
f=codecs.open("..\\dicts\\emcDict.py","wb")
pickle.dump(emcDict,f)
f.close()

f=codecs.open("..\\dicts\\mcbDict.py","wb")
pickle.dump(mcbDict,f)
f.close()

f=codecs.open("..\\dicts\\mckDict.py","wb")
pickle.dump(mckDict,f)
f.close()

f=codecs.open("..\\dicts\\emcFeaturesDict.py","wb")
pickle.dump(emcFeaturesDict,f)
f.close()

f=codecs.open("..\\dicts\\mcbFeaturesDict.py","wb")
pickle.dump(mcbFeaturesDict,f)
f.close()

